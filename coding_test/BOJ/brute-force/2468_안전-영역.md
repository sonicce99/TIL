## Link (실버 1)    

- https://www.acmicpc.net/problem/2468

## 내 풀이 (14804KB, 260ms)    

```javascript
const solution = (N, array) => {
  let max = -Infinity;
  const area = new Array(N).fill(null).map((_, i) => new Array(N).fill(null).map((_, j) => {
    return {
      height: array[i][j],
      isVisited: false,
      isOver: false
    }
  }));

  for(let i=0; i<N; i++) {
    for(let j=0; j<N; j++) {

      max = Math.max(max, array[i][j]);
    }
  }

  let answer = -Infinity;
  let temp = 0;
  const dfs = (depth, rain, y, x) => {
    if(x >= N || y >= N || x < 0 || y <0) {
      return;
    }

    if(area[y][x].isVisited) {
      return;
    }

    else {
      area[y][x].isVisited = true;
      area[y][x].isOver = area[y][x].height <= rain ? true : false;
      if(area[y][x].isOver) {
        return;
      }

      else {
        dfs(depth + 1, rain, y - 1, x);
        dfs(depth + 1, rain, y, x + 1);
        dfs(depth + 1, rain, y + 1, x);
        dfs(depth + 1, rain, y, x - 1);

        if(depth === 0) {
          temp++;
        }
      }
    }
  }

  for(let rain=0; rain<=max; rain++) {
    for(let y=0; y<N; y++) {
      for(let x=0; x<N; x++) {
        dfs(0, rain, y,x);
      }
    }
    answer = Math.max(answer, temp);
    temp = 0;

    for(let q=0; q<N; q++) {
      for(w=0; w<N; w++) {
        area[q][w].isVisited = false;
        area[q][w].isOver = false;
      }
    }
  }

  return answer;
}

const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');

const N = Number(input.shift());

const array = input.map(el => el.split(' ').map(Number));

console.log(solution(N, array));
```

시간 복잡도와 공간 복잡도는 상당히 만족스럽다.

node.js로 정답처리 받은 전체 151명 중 14등 했다.

하지만 코드 마지막 부분에 메모리 사용량을 낮추기 위해 area를 초기화 하는 부분 (2중 for문 쓴 부분) 때문에 좀 지저분한데 깔끔하게 정리할 수 있는 방법을 다시 생각해봐야겠다.
