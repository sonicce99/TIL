<h2>문제</h2>

<img width="400" alt="스크린샷 2021-08-24 오후 7 33 57" src="https://user-images.githubusercontent.com/87749134/130602369-849f1389-96ab-4b5f-9346-d2812ece1e28.png">
<img width="400" alt="스크린샷 2021-08-24 오후 7 34 06" src="https://user-images.githubusercontent.com/87749134/130602382-74a11997-0b7f-467a-af15-da1f3c85e5a3.png">
<img width="400" alt="스크린샷 2021-08-24 오후 7 35 59" src="https://user-images.githubusercontent.com/87749134/130602387-5545703f-abc0-4f98-adac-18b3ed2a24dd.png">


<h2>나의 문제 풀이</h2>

```
  function solution(numbers, hand) {
      let answer = [];
      let last_L= '*'
      let last_R= '#'
      const array =[[1,4,7,'*'],[2,5,8,0],[3,6,9,'#']];

      for(let a of numbers) {
          if(array[0].includes(a)) {
              last_L = a;
              answer.push("L")
          }
          else if (array[2].includes(a)) {
              last_R = a;
              answer.push("R")
          }
          else {

              let L=[]
              let R=[]

              array.forEach((k,i) => {
                if(k.includes(last_L)) {
                  L.push(i,k.indexOf(last_L))
                }
                if (k.includes(last_R)) {
                  R.push(i,k.indexOf(last_R))
                }
              })

              const countL = Math.abs(L[0]-1) + Math.abs(L[1]-array[1].indexOf(a));
              const countR = Math.abs(R[0]-1) + Math.abs(R[1]-array[1].indexOf(a));


              if(countL > countR) {
                last_R = a;
                answer.push("R")
              }
              else if (countL < countR) {
                last_L = a;
                answer.push("L")
              }
              else {
                hand==="right" ? last_R = a: last_L =a;
                hand==="right" ? answer.push("R") : answer.push("L")
              }
          }
      }

      return answer.join("")
  }
```

<h2>고수 풀이</h2>

```
  function solution(numbers, hand) {
      const hands = new Map();
      let answer = "";
      hands.set("left", "*");
      hands.set("right", "#");

      numbers.forEach((number) => {
          if ([1, 4, 7].includes(number)) {
              answer += "L";
              hands.set("left", number);
          } else if ([3, 6, 9].includes(number)) {
              answer += "R";
              hands.set("right", number);
          } else {
              answer += findNearest(hands, number, hand);
          }
      });

      return answer;
  }

  function findNearest(hands, number, hand) {
      const keypad = [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
          ["*", 0, "#"],
      ];

      const left = hands.get("left");
      const right = hands.get("right");
      let numIndex;
      let leftIndex;
      let rightIndex;

      keypad.forEach((arr, index) => {
          if (arr.includes(number)) numIndex = [index, arr.indexOf(number)];
          if (arr.includes(left)) leftIndex = [index, arr.indexOf(left)];
          if (arr.includes(right)) rightIndex = [index, arr.indexOf(right)];
      });

      const leftDistance = checkDistance(numIndex, leftIndex);
      const rightDistance = checkDistance(numIndex, rightIndex);

      if (leftDistance === rightDistance) {
          if (hand === "left") {
              hands.set("left", number);
              return "L";
          } else {
              hands.set("right", number);
              return "R";
              }
      } else {
          if (leftDistance < rightDistance) {
              hands.set("left", number);
              return "L";
          } else {
              hands.set("right", number);
              return "R";
          }
      }
  }

  function checkDistance(numIndex, hand) {
      if (numIndex[0] === hand[0]) {
          return Math.abs(numIndex[1] - hand[1]);
      }

      return (
          Math.abs(numIndex[0] - hand[0]) + Math.abs(numIndex[1] - hand[1])
      );
  }
```

- 내 코드 리뷰 : 2,5,8,0 의 값이 들어올 때 for of 대신 forEach를 사용한 이유 :
for of 는 배열의 값만 가져올 수 있는데 forEach는 배열의 값과 인덱스도 가져 올 수 있었기 때문에 2차원 배열에서 인덱스 값 2개를 다 알아 낼 수가 있었기 때문이다.

고수 풀이와 비슷하게 풀이했지만 이번 문제는 푸는데 거의 3일 정도 걸린것 같다..
