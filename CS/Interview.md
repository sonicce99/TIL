Architecture

1. 컴퓨터의 구성

- 하드웨어: CPU, 입출력장치, 메모리 (주기억장치, 보조기억장치)  

- 소프트웨어: 운영체제, 검파일러, 응용프로그램

2. 캐시메모리  

CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다.

속도라는 장점을 얻지만, 용량이 적기도 하고 비용이 비싼 점이 있다.

L1, L2, L3 캐시 메모리가 있고 L1이 가장 빠르다.

CPU가 요청한 데이터가 캐시에 있으면 'Cache Hit', 없어서 DRAM에서 가져오면 'Cache Miss'


3. 패리티 비트

종류 : 짝수 페리티, 홀수 페리티  

정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트를 말한다.

짝수 패리티일 때 7비트 데이터에서 1이 3개라면 1개를 추가해서 짝수개를 맞춰줍니다.


Network

1. OSI 7 계층

7계층을 나누는 이유: 통신이 일어나는 과정을 단계별로 알 수 있고, 문제가 생기면 그 부분만 수정 할 수 있기 떄문입니다.

7계층 (응용계층): http나 DNS와 통신을 할 수 있습니다. sender application layer가 socket에 data를 씀.  

6계층 (표현계층): 데이터의 암호화, 복호화, 인코딩, 디코딩을 진행합니다.

5계층 (세션계층): 데이터가 통신하기 위한 논리적인 연결을 담당합니다. TCP/IP 세션을 만들고 없애는 책임을 가지고 있습니다.

4계층 (전송계층): data를 segment에 감싼다. 그리고 network layer에 넘겨줍니다. TCP와 UDP 프로토콜을 통해 통신읋 활성화합니다. TCP는 신뢰성이있고, 연결지향적이지만 UDP는 신뢰성이 없고, 비연결성을 가지고 있습니다.

3계층 (네트워크 게층): 목적지까지 가기위한 최단경로를 차즌 기능을 합니다. 라우터를 통해 경로를 선택하고 데이터를 패킷 단위로 자릅니다.

2계층 (링크 계층): 데이터를 프레임 단위로 나누고, 컴퓨터의 Mac 주소를 통해 통신합니다.

1계층 (물리 계층): 비트 단위로 데이터가 전송되고, 케이블을 통해 데이터를 전송합니다.

2. TCP 3 way handshake & 4 way handshake

TCP는 정확한 전송을 보장해야합니다. 통신하기에 앞서, 논리적인 접속을 성립하기 위해 3 way handshake & 4 way handshake를 수행합니다.

- 3 way handshake (연결 수행)

클라이언트가 서버에게 SYN (Synchronization 동기회) 패킷을 보냄

서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK (Acknowledgement 승인)와 SYN 패킷을 보냄  

클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄

- 4 way handshake (연결 해제)

클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다.

서버는 FIN (Finish)을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. (이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다)

데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.

클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다.

3. TCP

연결성, 신뢰성이 있는 전송 프로토콜이다.

데이터의 순서가 뒤바뀌어도 자동으로 보정해주어서 정확한 송수신을 할 수 있게한다.

4. UDP (user datagram protocol)

데이터 그램 단위로 처리하는 프로토콜이다.

비연결성, 신뢰성이 없는 전송 프로토콜이다.

순서가 뒤바뀌거나 하지만 보정할 수 없다. 하지만 TCP보다 데이터의 처리가 빠르다. 주로 실시간 방송과 온라인게임에서 사용됩니다. 네트워크환경이 안좋을 때, 끊기는 현상을 생각하면 됩니다.


5. http & https

https에서 s는 secure이고 보안이 더 강회된 http입니다.

https는 SSL 인증서에서 돌아가게됩니다.

SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서입니다. 클라이언트가 서버에 접속한 직후 서버는 클라이언트에게 이 인증서 정보를 전달합니다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증한 후에 다음 절차를 수행합니다.

- 대칭키: SSL 인증서의 핵심은 암호화입니다. 대칭키에 따라서 암호화된 결과가 달라지기 때문에 이 키를 모르면 복호화 할 수가 없습니다. 예를 들어 암호화 할 때 1234라는 값을 사용했다면 복호화 할 때에도 1234를 사용해야 합니다. 단점은 대칭키를 멀리 있는 상대방도 알아야한다는 점입니다.

- 공개키: 클라이언트가 서버에 데이터를 요청하면 클라이언트와 서버는 서로 자신의 공개키를 서로에게 전달합니다. 그러면 클라이언트는 서버가 준 공개키를 가지고 암호화를 해서 서버에 암호화된 데이터를 전송하고 서버는 해당 데이터를 가지고 자신만 알고 있는 비공개키를 사용하여 데이터를 복호화합니다.

하지만 실제 SSL이 동작할 때는 대칭키와 공개키를 혼합해서 사용합니다. 왜냐하면 공개키를 사용해서 데이터를 암호화 하는것이 대칭키를 통해서 암호화하는 것보다 성능을 많이 잡아먹기 때문입니다.

따라서 우선 클라이언트와 서버는 handshake를 통해서 서로의 공개키를 주고 받습니다. 그 다음 클라이언트는 보내고 싶은 데이터를 대칭키를 사용하여 암호화합니다. 그리고 대칭키를 공개키로 대칭키를 암호화해서 서버에 전송합니다. 그러면 서버는 비공개키를 가지고 대칭키를 복호화하고 데이터를 가져올 수 있습니다.

6. 로드 밸런싱

요즘 시대에는 웹사이트에 접속하는 인원이 급격히 늘어나게 되었다.

따라서 이 사람들에 대해 모든 트래픽을 감당하기엔 1대의 서버로는 부족하다. 대응 방안으로 하드웨어의 성능을 올리거나(Scale-up) 여러대의 서버가 나눠서 일하도록 만드는 것(Scale-out)이 있다. 하드웨어 향상 비용이 더욱 비싸기도 하고, 서버가 여러대면 무중단 서비스를 제공하는 환경 구성이 용이하므로 Scale-out이 효과적이다. 이때 Load Balancer를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 것이 바로 로드 밸런싱이다.  

이때 Load Balancer가 서버를 선택하는 방식

- 라운드로빈 (선점형 스케쥴링 -> 일정 시간 후에 다른 프로세스가 진행)  

- 연결 갯수가 가장 적은 서버 선택

- 사용자의 IP에 따라 분배  


운영체제  

1. 운영체제의 역할

- 프로세스 관리: 프로세스를 할당, 해제를 결정하고, 프로세스들간의 공유자원 접근을 관리  

- 저장장치 관리: 1차 저장장치와 2차 저장장치 관리  

- 네트워킹  

- 사용자 관리: 하나의 컴퓨터에서 각 계정별로 관리  

2. 프로세스 & 스레드  

기본적으로 하나의 프로세스에는 1개의 스레드를 가지고 있다.

3. 스케쥴링

- 선점 스케쥴링: 운영체제가 CPU의 사용권을 선점 할 수 있는 경우. (처리 시간 예측 어려움) / 우선순위순, 라운드로빈  

- 비선점 스케쥴링: 프로세스가 종료된거나 특정 이벤틀 발생 전까지의 실행을 보장 (처리시간 예측 용이) / FCFS, SJF


4. 데드락 (교착상태)  

두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해 무한히 다음 자원을 기다리게 되는 상태를 말한다.  

시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

- 발생 조건: 상호배제, 점유 대기, 비선점, 순환대기  

비선점: 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

순환대기: 순환 형태로 자원을 대기하고 있어야 함


모노리틱 -> 마이크로서비스 아키텍처(MSA)

MSA란 각각의 서비스가 독립된 DB를 가지는 것을 말합니다. 이러한 특성 덕분에 시스템 전체의 중단 없이 필요한 부분만 업데이트·배포가 가능합니다. 또한 서버를 Scale-out 함에 있어서도 해당 부분만 수정하면 되므로 기존의 다른 부분을 크게 고려할 필요가 없어진다는 장점이 있습니다.
