## Architecture

1. 컴퓨터의 구성

- 하드웨어: CPU, 입출력장치, 메모리 (주기억장치, 보조기억장치)  

- 소프트웨어: 운영체제, 검파일러, 응용프로그램

2. 캐시메모리  

CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다.

속도라는 장점을 얻지만, 용량이 적기도 하고 비용이 비싼 점이 있다.

L1, L2, L3 캐시 메모리가 있고 L1이 가장 빠르다.

CPU가 요청한 데이터가 캐시에 있으면 'Cache Hit', 없어서 DRAM에서 가져오면 'Cache Miss'


3. 패리티 비트

종류 : 짝수 페리티, 홀수 페리티  

정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트를 말한다.

짝수 패리티일 때 7비트 데이터에서 1이 3개라면 1개를 추가해서 짝수개를 맞춰줍니다.


## Network

1. 브라우저에서 주소를 입력 하였을때 해당 주소로 접속하게되는 과정을 osi 7 레이어 순서대로 설명 해보세요.

도메인을 ip주소로 변환해야 하기 때문에 DNS서버에서 ip주소를 우선적으로 받아오게됩니다. 하지만 로컬 컴퓨터에서 DNS cache파일이나 hosts파일에 ip주소가 있다면 그 값을 대신 사용하기도 합니다. 또한 서버 중에서 CDN이라는 (Content Delivery Network) 라는 서비스를 사용하고 있다면, 클라이언트의 위치에 맞게 가장 원활한 위치의 서버 ip주소를 받아오기도 합니다.

4계층에서는 http통신을 하기 위해서 TCP 소켓을 열고 3-way-handshake로 서버-클라이언트간의 세션을 수립합니다. 이때 port번호를 포함해서 데이터를 Segment단위로 3계층인 네트워크 layer로 전달합니다.

네트워크 layer에서는 서로 다른 네트워크에서 목적지까지 가기위한 최단경로를 찾는 기능을 합니다. 라우터를 통해 경로를 선택하고 데이터를 패킷 단위로 자릅니다.

2계층에서는 같은 네트워크에 있는 여러대의 컴퓨터들이 데이터를 주고 받기 위한 링크 프로토콜이 존재합니다, 이들은 물리적으로 연결되어 있으며, LAN이라는 네트워크에 연결됩니다. 이때 같은 LAN에 존재하는 여러 호스트들은 NIC의 Mac 주소를 통해 구분됩니다.  데이터는 frame 단위로 나뉘게 되며 물리 계층으로 넘어갑니다.

물리계층에서는 데이터를 bit 단위로 나누게 되며, 통신케이블을 통해 데이터가 이동합니다.

request와 response를 받은 후 4-way-handshake를 통해 세션을 종료합니다.



2. TCP 3 way handshake & 4 way handshake

TCP는 정확한 전송을 보장해야합니다. 통신하기에 앞서, 논리적인 접속을 성립하기 위해 3 way handshake & 4 way handshake를 수행합니다.

- 3 way handshake (연결 수행)

클라이언트가 서버에게 SYN (Synchronization 동기화) 패킷을 보냄

서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK (Acknowledgement 승인)와 SYN 패킷을 보냄  

클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄

- 4 way handshake (연결 해제)

클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다.

서버는 FIN (Finish)을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. (이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다)

데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.

클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다.

3. TCP

연결성, 신뢰성이 있는 전송 프로토콜이다.

데이터의 순서가 뒤바뀌어도 자동으로 보정해주어서 정확한 송수신을 할 수 있게한다.

4. UDP (user datagram protocol)

데이터 그램 단위로 처리하는 프로토콜이다.

비연결성, 신뢰성이 없는 전송 프로토콜이다.

순서가 뒤바뀌거나 하지만 보정할 수 없다. 하지만 TCP보다 데이터의 처리가 빠르다. 주로 실시간 방송과 온라인게임에서 사용됩니다. 네트워크환경이 안좋을 때, 끊기는 현상을 생각하면 됩니다.


5. http & https

https에서 s는 secure이고 보안이 더 강회된 http입니다.

https는 SSL 인증서에서 돌아가게됩니다.

SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서입니다. 클라이언트가 서버에 접속한 직후 서버는 클라이언트에게 이 인증서 정보를 전달합니다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증한 후에 다음 절차를 수행합니다.

- 대칭키: SSL 인증서의 핵심은 암호화입니다. 대칭키에 따라서 암호화된 결과가 달라지기 때문에 이 키를 모르면 복호화 할 수가 없습니다. 예를 들어 암호화 할 때 1234라는 값을 사용했다면 복호화 할 때에도 1234를 사용해야 합니다. 단점은 대칭키를 멀리 있는 상대방도 알아야한다는 점입니다.

- 공개키: 클라이언트가 서버에 데이터를 요청하면 클라이언트와 서버는 서로 자신의 공개키를 서로에게 전달합니다. 그러면 클라이언트는 서버가 준 공개키를 가지고 암호화를 해서 서버에 암호화된 데이터를 전송하고 서버는 해당 데이터를 가지고 자신만 알고 있는 비공개키를 사용하여 데이터를 복호화합니다.

하지만 실제 SSL이 동작할 때는 대칭키와 공개키를 혼합해서 사용합니다. 왜냐하면 공개키를 사용해서 데이터를 암호화 하는것이 대칭키를 통해서 암호화하는 것보다 성능을 많이 잡아먹기 때문입니다.

따라서 우선 클라이언트와 서버는 handshake를 통해서 서로의 공개키를 주고 받습니다. 그 다음 클라이언트는 보내고 싶은 데이터를 대칭키를 사용하여 암호화합니다. 그리고 대칭키를 공개키로 대칭키를 암호화해서 서버에 전송합니다. 그러면 서버는 비공개키를 가지고 대칭키를 복호화하고 데이터를 가져올 수 있습니다.

6. 로드 밸런싱

요즘 시대에는 웹사이트에 접속하는 인원이 급격히 늘어나게 되었다.

따라서 이 사람들에 대해 모든 트래픽을 감당하기엔 1대의 서버로는 부족하다. 대응 방안으로 하드웨어의 성능을 올리거나(Scale-up) 여러대의 서버가 나눠서 일하도록 만드는 것(Scale-out)이 있다. 하드웨어 향상 비용이 더욱 비싸기도 하고, 서버가 여러대면 무중단 서비스를 제공하는 환경 구성이 용이하므로 Scale-out이 효과적이다. 이때 Load Balancer를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 것이 바로 로드 밸런싱이다.  

이때 Load Balancer가 서버를 선택하는 방식

- 라운드로빈 (선점형 스케쥴링 -> 일정 시간 후에 다른 프로세스가 진행)  

- 연결 갯수가 가장 적은 서버 선택

- 사용자의 IP에 따라 분배  

7. 스레드는 무엇인가요?

스레드는 하나의 프로세스 내에서 실행되는 작업의 단위입니다. 프로세스에는 BSS, TEXT, DATA, STACK, HEAP 세그먼트의 메모리 구조를 가지는데 스레드는 프로세스의 Stack 세그먼트에서 생성이 되며 프로세스의 나머지 메모리에 자유롭게 접근할 수 있습니다. 그래서 일반적으로 생성 및 소멸이 빠르고, 컨텍스트 스위칭(Context Switching) 비용이 적어서, 프로세스를 생성하는 것보다 경제적이라는 특징을 가지고 있습니다. 스레드는 대부분의 모던 프로그래밍 언어에서 지원되며, 멀티스레드 프로그래밍은 병렬성(Parallelism) 및 동시성(Concurrency) 문제를 해결할 수 있는 중요한 기술입니다.


## 운영체제  

1. 운영체제의 역할

- 프로세스 관리: 프로세스를 할당, 해제를 결정하고, 프로세스들간의 공유자원 접근을 관리  

- 저장장치 관리: 1차 저장장치와 2차 저장장치 관리  

- 네트워킹  

- 사용자 관리: 하나의 컴퓨터에서 각 계정별로 관리  

2. 프로세스 & 스레드  

기본적으로 하나의 프로세스에는 1개의 스레드를 가지고 있다.

3. 스케쥴링

- 선점 스케쥴링: 운영체제가 CPU의 사용권을 선점 할 수 있는 경우. (처리 시간 예측 어려움) / 우선순위순, 라운드로빈  

- 비선점 스케쥴링: 프로세스가 종료된거나 특정 이벤틀 발생 전까지의 실행을 보장 (처리시간 예측 용이) / FCFS, SJF


4. 데드락 (교착상태)  

두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해 무한히 다음 자원을 기다리게 되는 상태를 말한다.  

시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

- 발생 조건: 상호배제, 점유 대기, 비선점, 순환대기  

비선점: 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

순환대기: 순환 형태로 자원을 대기하고 있어야 함


모노리틱 -> 마이크로서비스 아키텍처(MSA)

MSA란 각각의 서비스가 독립된 DB를 가지는 것을 말합니다. 이러한 특성 덕분에 시스템 전체의 중단 없이 필요한 부분만 업데이트·배포가 가능합니다. 또한 서버를 Scale-out 함에 있어서도 해당 부분만 수정하면 되므로 기존의 다른 부분을 크게 고려할 필요가 없어진다는 장점이 있습니다.


## Javascript

1. 브라우저 동작 원리

렌더링 엔진은 HTML파일과 CSS파일을 읽습니다. HTML 파일은 HTML parser에 의해 DOM 트리를 만들고 CSS 파일은 CSS parser에 의해 CSSOM 트리로 변환됩니다. 이때 HTML parser가 script를 만나게 되면 javascript 코드를 실행하기 위해 자바스크립트 엔진으로 제어권을 넘깁니다. 자바스크립트엔진은 자바스크립트코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환하여 syntax tree를 생성하고 바이트코드로 변환하여 실행합니다. 이때 자바스크립트는 DOM Api를 통해 DOM이나 CSSOM을 변경할 수 있습니다. 이렇게 만들어진 DOM과 CSSOM은 render 트리로 결합됩니다. 이렇게 생성된 렌더 트리는 레이아웃, 페인딩 작업을 거친 후 보여지게 됩니다. 이때 모든 HTML요소들을 렌더링 엔진으로 넣어서 한번에 출력하는 것이 아닌, 일부 컨텐츠는 먼저 트리 과정을 거쳐 스크린에 나타나고, 다른 요소들은 네트워크를 통해 렌더링 엔진으로 읽어오는 순차적인 방식으로 입출력이 진행됩니다.

2. 호이스팅

자바스크립트는 인터프리터 언어로서 인터프리터에 의해 한줄씩 순차적으로 실행됩니다. 하지만 실제로 한줄씩 실행되는 런타임 이전에 자바스크립트는 실행컨텍스트를 생성을 위한 환경정보를 먼저 구성합니다. 이때 variable environment와 Lexcical environment가 생성되는데 Lexcical environment은 2가지로 나뉘게 되며, environment Record와 outer environment reference가 있습니다, environment Record에는 현재 컨텍스트의 식별자 정보를 저장합니다. 따라서, 실제로 var, let, const, function과 같은 식별자들이 코드 최상단으로 끌어올려지는 것은 아니지만 마치 최상단에 끌어올려진것 처럼 보이게 되는데 이것이 호이스팅의 개념입니다.

3. 클로저

클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다. 자바스크립트의 모든 함수는 outerEnvirenmentReferrence를 통해 자신의 상위스코프를 기억합니다. 따라서 외부함수의 실행컨택스트가 콜스택에서 사라지더라도 외부 함수 내부의 중첩함수는 외부 함수의 렉시컬 환경을 기억하기 때문에 외부 변수에 접근할 수 있습니다. 클로저는 상태를 안전하게 변경하고 유지하기 위해, 안전하게 은닉하기 위해 사용합니다.


4. this의 용법

this는 자신이 속한 객체나 자신이 생성할 instance를 가리키는 자기 참조 변수입니다. this는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 함수를 호출하면 암묵적으로 this가 전달됩니다.
함수를 함수로서 호출할 때와 메서드로서 호출할 때 바인딩 되는 this의 값이 달라지게 됩니다.
함수로서 호출하게 되면 this는 window 즉 전역객체를 바라보게 되고, 메서드로서 호출하게 된다면 객체 자기 자신을 바라보게 됩니다.
ES6에서는 이렇게 함수가 전역객체를 바라보는 것을 막고자 화살표 함수를 만들게 되었고, 화살표 함수는 this 자체를 바인딩하지 않기 때문에 함수의 상위 스코프에 있는 this를 그대로 활용할 수 있습니다.

apply: 객체와 array인수가 필요.  

call: 객체와 인수를 풀어서 전달.  

bind: 객체만 전달.

5. LocalStorage, SessionStorage, cookie 차이

LocalStorage, SessionStorage는 웹 브라우저 자체에 있는 특정 저장 공간입니다.
최대 5MB까지 저장이 가능하며 문자열만 저장이 가능합니다. LocalStorage는 지정된 값을 삭제하기 전까지 브라우저에 계속 그 값이 남아있습니다. 반면 SessionStorage 현재 떠 있는 텝 내에서만 유지되고 브라우저 창을 닫는 순간 사라진다는 특징이 있습니다. 쿠키는 네트워크 요청시 서버로 전송될 데이터를 저장해 놓는다는 특징이 있습니다.

6. 이벤트 버블링과 캡쳐링에 대해서 설명

이벤트 버블링은 화면의 특정 부분에서 이벤트가 발생했을 때 그 요소의 부모요소로 이벤트가 전달되는 것을 의미합니다.

이벤트 캡쳐는 반대방향을 의미합니다. addEventListener에서 option값으로 capture: true 값을 넣어주면 됩니다.

event.stopPropagation()은 해당 이벤트가 전파되는 것을 막습니다.


7. 제너레이터

제너레이터는 함수의 실행을 yield 키워드를 통해 일시 중지했다가 필요한 시점에 next 메서드를 통해 재개할 수 있는 특수한 함수입니다. 따라서 함수의 제어권을 함수가 독점하는 것이 아니라 함수 호출자에게 양도할 수 있습니다. function 키워드와 함수 이름 사이에 *가 하나 존재해야하며 하나 이상의 yield를 표함해야합니다.

8. CORS

대부분의 웹 브라우저는 SOP (Same Origin Policy) 라는 보안 정책을 준수한다.
다른 Origin의 데이터를 읽고 싶으면 CORS 표준을 지켜서 요청하면된다. 이 문제를 해결하기 위해서 서버에서 해당 origin을 통과 시키거나, Proxy를 사용해서 origin을 우회하면 됩니다. 왜나햐면 CORS는 브라우저에 관련된 정책이기 때문에 Proxy 서버를 통해서 전달하는 요청에 대해서는 문제가 되지 않습니다.


9. 프로토타입 체이닝

자바스크립트는 객체의 프로퍼티에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티가 없다면, [[Prototype]] 내부 슬롯의 참조를 따라 부모의 prototype의 프로퍼티를 순차적으로 검색하는데 이것을 프로토타입체이닝이라고 합니다. 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 개념입니다.

10. 객체지향 프로그래밍은 무엇인가요?

객체지향 프로그래밍은 Object-oriented-programming 을 줄여 OOP라고 부르며, 객체라는 개념을 중심으로 구성되어 있습니다. 객체란 현실 세계에서 사물이나 개념을 의미합니다. 이러한 객체는 속성 (attribute)과 행동 (Method) 으로 구성되어 있습니다. 속성은 객체의 특성을 나타내며, 행동은 객체가 수행할 수 있는 작업을 의미합니다. (속성, 행위 캡슐화, 은닉화)

11. Rest Api에 대해 설명해주세요.

URI와, HTTP 메서드를 통해 자원에 대한 CRUD를 적용하는 것을 의미합니다. Rest의 구성요소로는 자원, 행위, 표현이 있으며, Server-client구조와 , stateless하다는 특징이 있고, Rest의 장점으로는 요청을 보면 어떤 동작과 목표가 있는지 정확히 추론이 가능하다는 점입니다. 또한 클라이언트와 서버의 역할을 명확하게 분리하고, HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다는 장점이 있습니다. 반면에 표준이 존재하지 않고, 사용할 수 있는 메소드가 4가지 밖에 없다. 는 단점도 있습니다.


12. async/await

async / await 은 promise를 기반으로 동작합니다. 하지만 then, catch, finally와 같은 후속처리를 사용할 필요없이 promise를 사용하여 가독성을 크게 올릴 수 있습니다.

13. URL, URI

L은 Locator로서 위치를 의미하고, I는 Indicator로서 식별을 의미합니다.
URL은 protocol, domnain, port 번호, Path까지만을 의미하지만 URI는 뒤이어 Query-String과 Fragment까지를 포함합니다.

14. Webpack 사용 이유

Webpack은 프로젝트에 필요한 모든 모듈을 매핑하고, 하나 이상의 번들을 생성하는 디펜던시 그래프를 만듭니다. 따라서 javascript파일을 하나의 파일로 번들링하여 불필요한 네트워크 요청을 줄일 수 있습니다. 또한 처음 로딩할 때 필요한 코드만 불러오고 필요하지 않은 코드는 나중에 필요할 때 로딩 할 수 있도록 code spliting기능도 제공합니다. 마지막으로 webpack은 다양한 로더를 제공하여, 다양한 유형의 파일을 모듈로 인식하고 해당 파일을 처리할 수 있습니다. 예를 들어, Babel 로더를 사용하여 ES6 코드를 ES5 코드로 변환할 수 있습니다.

16. Redux 동작원리

Redux의 동작원리는 크게 3가지가 있습니다. Store, Action, Reducer입니다. Store는 모든 상태 값을 가지고 있으며, 상태 값이 업데이트 되면 이전 상태값과 새로운 상태값을 비교하여 변경사항을 확인하고 업데이트합니다.
Redux에서 상태 값을 변경하기 위해서는 action이라는 객체를 만들어야합니다. 일반적으로 type이라는 프로퍼티를 가지고 있습니다.
Reducer는 상태값이 어떻게 업데이트 되는지 정의하는 함수입니다. Reducer는 이전 상태값을 받아서 action 객체를 이용해 새로운 상태값을 생성하고, 이를 store에 저장합니다. Reducer는 불변성을 유지해야합니다.


17. 스코프 체인

모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프입니다. 이렇게 스코프가 계층적으로 연결되는 것을 스코프체인이라고 합니다.

18. strict mode

ES5 부터 추가된 문법으로 자바스크립트의 문법을 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나, 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킵니다. strict mode를 사용하기 위해서는 전역의 가장 윗 부분에 'use strict' 구문을 추가한다.


19. reconciliation (조화 과정)  

DOM을 조작하는 업데이트가 너무 자주 일어나면, reflow와 repaint를 하는데 성능상의 이슈가 생기게 됩니다. reflow와 repaint를 최소화 하기 위해 리액트는 virtual DOM을 사용하여 변경된 데이터로 새로운 DOM트리를 만듭니다. 이때 render함수가 반환하는 결과를 바로 DOM에 반영하지 않고 기존의 DOM트리와 virtual DOM을 비교하여 최소한의 연산으로 DOM을 업데이트하는데 이를 reconciliation 이라 합니다.

20. DOM이란?

document object model의 약어로, 문서구조를 객체로 표현하는 방법입니다.

21. JSX란?

React에서 자바스크립트로 개발을 편하게 하기 위한 javascript 확장 문법입니다.

22. Map, Set 자료구조에 대해 설명해보세요.

Map은 key와 value로 구성된 데이터를 저장할 수 있는 자료구조입니다. 객체와 비슷한 구조를 가지고 있지만, key값으로 어떤 값이든지 사용할 수 있다는 특징이 있습니다.

Set은 중복되지 않는 값을 저장하는 자료구조입니다. Set은 배열과 비슷한 구조를 가지고 있지만, 중복되는 값이 저장되지 않는다는 차이점이 있습니다.

Map과 Set은 모두 이터러블(iterable) 객체이므로, for...of 루프를 사용하여 요소를 순회할 수 있습니다

23. 함수형 프로그래밍에 대해서 어떻게 생각하나요?

함수형 프로그래밍에서 함수는 일급 객체이며, 부작용(side-effect)을 최소화하고 입력과 출력만으로 동작합니다. 이러한 특성으로 인해 함수형 프로그래밍은 순수 함수(pure function)를 이용한 불변성(immutability)을 유지하는 프로그래밍 방식으로, 오류가 줄어들고 코드의 가독성과 유지보수성이 향상됩니다.

함수형 프로그래밍에서는 재귀(recursion)와 고차함수(higher-order function)를 적극적으로 활용합니다. 재귀는 반복문 대신에 사용되며, 고차함수는 함수를 인자로 받아들이거나 반환하는 함수를 의미합니다. 이러한 특성으로 인해 함수형 프로그래밍은 코드의 재사용성과 모듈성을 높이며, 코드의 중복을 줄여줍니다.

또한, 함수형 프로그래밍은 멀티스레드 환경에서 안전하며, 분산 시스템에서 쉽게 확장될 수 있는 등 병렬성과 분산성을 구현하기 쉽습니다.

24. CSS in JS 방식과 CSS 전처리기에 대해 설명헤주세요.

CSS 전처리기는 Sass, Less, Stylus 등이 있으며, 이러한 전처리기를 사용하면 CSS 코드를 작성할 때 변수, 함수, 중첩 등을 사용할 수 있어서 코드의 가독성을 높이고 유지보수성을 높일 수 있습니다. 그러나, CSS 파일을 생성하므로 브라우저에서 실시간으로 변경된 내용을 적용하기 어려우며, 서버에서 CSS 파일을 생성하므로 추가적인 네트워크 비용이 발생할 수 있습니다.

CSS in JS는 CSS 코드를 JavaScript 파일 안에서 작성하는 방식입니다. 이러한 방식을 사용하면 CSS와 JavaScript의 결합으로 인한 유지보수성과 모듈화가 용이하며, 코드를 작성할 때 JavaScript의 변수, 함수, 조건문 등을 사용할 수 있어서 유연성이 높아집니다. 또한, CSS in JS는 브라우저에서 실시간으로 변경된 내용을 적용할 수 있으며, 컴파일러를 사용하여 최적화된 CSS 코드를 생성하기 때문에 불필요한 코드가 생성되지 않습니다. 그러나, CSS in JS 방식은 새로운 개념과 문법을 배워야 한다는 점도 있습니다.
