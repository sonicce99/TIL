Architecture

1. 컴퓨터의 구성

- 하드웨어: CPU, 입출력장치, 메모리 (주기억장치, 보조기억장치)  

- 소프트웨어: 운영체제, 검파일러, 응용프로그램

2. 캐시메모리  

CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다.

속도라는 장점을 얻지만, 용량이 적기도 하고 비용이 비싼 점이 있다.

L1, L2, L3 캐시 메모리가 있고 L1이 가장 빠르다.

CPU가 요청한 데이터가 캐시에 있으면 'Cache Hit', 없어서 DRAM에서 가져오면 'Cache Miss'


3. 패리티 비트

종류 : 짝수 페리티, 홀수 페리티  

정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트를 말한다.

짝수 패리티일 때 7비트 데이터에서 1이 3개라면 1개를 추가해서 짝수개를 맞춰줍니다.


Network

1. OSI 7 계층

7계층을 나누는 이유: 통신이 일어나는 과정을 단계별로 알 수 있고, 문제가 생기면 그 부분만 수정 할 수 있기 떄문입니다.

7계층 (응용계층): OSI 7계층 모델에서 최상위 계층으로 사용자가 네트워크 자원에 접근하는 방법을 제공하며 http가 있습니다.

6계층 (표현계층): 데이터의 암호화, 복호화, 인코딩, 디코딩을 진행합니다.

5계층 (세션계층): 데이터가 통신하기 위한 논리적인 연결을 담당합니다. TCP/IP 세션을 만들고 없애는 책임을 가지고 있습니다.

4계층 (전송계층): Port번호를 포함해서 데이터를 Segment단위로 전달됩니다.

3계층 (네트워크 게층): 서로 다른 네트워크에서 목적지까지 가기위한 최단경로를 찾는 기능을 합니다. 라우터를 통해 경로를 선택하고 데이터를 패킷 단위로 자릅니다.  

2계층 (링크 계층): 같은 네트워크에 있는 여러 대의 컴퓨터들이 데이터를 주고 받기 위한 링크 프로토콜이 존재합니다. 이들은 물리적으로 연결되어 있으며, LAN이라는 네트워크에 연결됩니다. 이 LAN에 연결하기 위해서 컴퓨터는 무조건 NIC가 존재해야합니다. 이 NIC에는 Mac 주소가 있습니다. 데이터는 프레임 단위로 자릅니다.

1계층 (물리 계층): 비트 단위로 데이터가 전송되고, 케이블을 통해 데이터를 전송합니다.

2. TCP 3 way handshake & 4 way handshake

TCP는 정확한 전송을 보장해야합니다. 통신하기에 앞서, 논리적인 접속을 성립하기 위해 3 way handshake & 4 way handshake를 수행합니다.

- 3 way handshake (연결 수행)

클라이언트가 서버에게 SYN (Synchronization 동기화) 패킷을 보냄

서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK (Acknowledgement 승인)와 SYN 패킷을 보냄  

클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄

- 4 way handshake (연결 해제)

클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다.

서버는 FIN (Finish)을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. (이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다)

데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.

클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다.

3. TCP

연결성, 신뢰성이 있는 전송 프로토콜이다.

데이터의 순서가 뒤바뀌어도 자동으로 보정해주어서 정확한 송수신을 할 수 있게한다.

4. UDP (user datagram protocol)

데이터 그램 단위로 처리하는 프로토콜이다.

비연결성, 신뢰성이 없는 전송 프로토콜이다.

순서가 뒤바뀌거나 하지만 보정할 수 없다. 하지만 TCP보다 데이터의 처리가 빠르다. 주로 실시간 방송과 온라인게임에서 사용됩니다. 네트워크환경이 안좋을 때, 끊기는 현상을 생각하면 됩니다.


5. http & https

https에서 s는 secure이고 보안이 더 강회된 http입니다.

https는 SSL 인증서에서 돌아가게됩니다.

SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서입니다. 클라이언트가 서버에 접속한 직후 서버는 클라이언트에게 이 인증서 정보를 전달합니다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증한 후에 다음 절차를 수행합니다.

- 대칭키: SSL 인증서의 핵심은 암호화입니다. 대칭키에 따라서 암호화된 결과가 달라지기 때문에 이 키를 모르면 복호화 할 수가 없습니다. 예를 들어 암호화 할 때 1234라는 값을 사용했다면 복호화 할 때에도 1234를 사용해야 합니다. 단점은 대칭키를 멀리 있는 상대방도 알아야한다는 점입니다.

- 공개키: 클라이언트가 서버에 데이터를 요청하면 클라이언트와 서버는 서로 자신의 공개키를 서로에게 전달합니다. 그러면 클라이언트는 서버가 준 공개키를 가지고 암호화를 해서 서버에 암호화된 데이터를 전송하고 서버는 해당 데이터를 가지고 자신만 알고 있는 비공개키를 사용하여 데이터를 복호화합니다.

하지만 실제 SSL이 동작할 때는 대칭키와 공개키를 혼합해서 사용합니다. 왜냐하면 공개키를 사용해서 데이터를 암호화 하는것이 대칭키를 통해서 암호화하는 것보다 성능을 많이 잡아먹기 때문입니다.

따라서 우선 클라이언트와 서버는 handshake를 통해서 서로의 공개키를 주고 받습니다. 그 다음 클라이언트는 보내고 싶은 데이터를 대칭키를 사용하여 암호화합니다. 그리고 대칭키를 공개키로 대칭키를 암호화해서 서버에 전송합니다. 그러면 서버는 비공개키를 가지고 대칭키를 복호화하고 데이터를 가져올 수 있습니다.

6. 로드 밸런싱

요즘 시대에는 웹사이트에 접속하는 인원이 급격히 늘어나게 되었다.

따라서 이 사람들에 대해 모든 트래픽을 감당하기엔 1대의 서버로는 부족하다. 대응 방안으로 하드웨어의 성능을 올리거나(Scale-up) 여러대의 서버가 나눠서 일하도록 만드는 것(Scale-out)이 있다. 하드웨어 향상 비용이 더욱 비싸기도 하고, 서버가 여러대면 무중단 서비스를 제공하는 환경 구성이 용이하므로 Scale-out이 효과적이다. 이때 Load Balancer를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 것이 바로 로드 밸런싱이다.  

이때 Load Balancer가 서버를 선택하는 방식

- 라운드로빈 (선점형 스케쥴링 -> 일정 시간 후에 다른 프로세스가 진행)  

- 연결 갯수가 가장 적은 서버 선택

- 사용자의 IP에 따라 분배  


운영체제  

1. 운영체제의 역할

- 프로세스 관리: 프로세스를 할당, 해제를 결정하고, 프로세스들간의 공유자원 접근을 관리  

- 저장장치 관리: 1차 저장장치와 2차 저장장치 관리  

- 네트워킹  

- 사용자 관리: 하나의 컴퓨터에서 각 계정별로 관리  

2. 프로세스 & 스레드  

기본적으로 하나의 프로세스에는 1개의 스레드를 가지고 있다.

3. 스케쥴링

- 선점 스케쥴링: 운영체제가 CPU의 사용권을 선점 할 수 있는 경우. (처리 시간 예측 어려움) / 우선순위순, 라운드로빈  

- 비선점 스케쥴링: 프로세스가 종료된거나 특정 이벤틀 발생 전까지의 실행을 보장 (처리시간 예측 용이) / FCFS, SJF


4. 데드락 (교착상태)  

두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해 무한히 다음 자원을 기다리게 되는 상태를 말한다.  

시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

- 발생 조건: 상호배제, 점유 대기, 비선점, 순환대기  

비선점: 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

순환대기: 순환 형태로 자원을 대기하고 있어야 함


모노리틱 -> 마이크로서비스 아키텍처(MSA)

MSA란 각각의 서비스가 독립된 DB를 가지는 것을 말합니다. 이러한 특성 덕분에 시스템 전체의 중단 없이 필요한 부분만 업데이트·배포가 가능합니다. 또한 서버를 Scale-out 함에 있어서도 해당 부분만 수정하면 되므로 기존의 다른 부분을 크게 고려할 필요가 없어진다는 장점이 있습니다.


////////////////////////

1. 브라우저 동작 원리

렌더링 엔진은 HTML파일과 CSS파일을 읽습니다. HTML 파일은 HTML parser에 의해 DOM 트리를 만들고 CSS 파일은 CSS parser에 의해 CSSOM 트리로 변환됩니다. 이때 HTML parser가 script를 만나게 되면 javascript 코드를 실행하기 위해 자바스크립트 엔진으로 제어권을 넘깁니다. 이렇게 만들어진 DOM과 CSSOM은 render 트리로 결합됩니다. 이렇게 생성된 렌더 트리는 레이아웃, 페인딩 작업을 거친 후 보여지게 됩니다. 이때 모든 HTML요소들을 렌더링 엔진으로 넣어서 한번에 출력하는 것이 아닌, 일부 컨텐츠는 먼저 트리 과정을 거쳐 스크린에 나타나고, 다른 요소들은 네트워크를 통해 렌더링 엔진으로 읽어오는 순차적인 방식으로 입출력이 진행됩니다.

2. 호이스팅

어떤 함수가 실행이되면 자바스크립트는 실행컨텍스트를 생성을 위한 환경정보를 구성합니다. 이때 variable environment와 Lexcical environment가 생성되는데 저희가 주목해야 할 것은 Lexcical environment입니다. Lexcical environment은 또 2가지로 나뉘게 되는데 environment Record와 outer environment reference가 있습니다, environment Record에는 현재 컨텍스트의 식별자 정보가 담기게 됩니다. 컨택스트 내부를 처음부터 끝까지 쭉 훑어나가며 순서대로 수집합니다. 즉, 실제로 식별자들을 코드 최상단으로 끌어올려놓는 것은 아니지만 마치 식별자들을 모두 코드 최상단에 끌어올려놓은 다음 실제 코드를 실행한다고 생각하더라도 문제가 없는 것처럼 보이게 됩니다. 이것이 호이스팅의 개념입니다.

3. 클로저

클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다. 클로저를 사용하는 이유는 변수를 은닉화 할 수 있기 때문입니다. 함수 내부에는 실제로 해당 변수가 없다고 보이기 때문입니다.

4. this의 용법

함수를 함수로서 호출할 때와 메서드로서 호출할 때 바인딩 되는 this의 값이 달라지게 됩니다.
함수로서 호출하게 되면 this는 window 즉 전역객체를 바라보게 되고, 메서드로서 호출하게 된다면 객체 자기 자신을 바라보게 됩니다.
ES6에서는 이렇게 함수가 전역객체를 바라보는 것을 막고자 화살표 함수를 만들게 되었고, 화살표 함수는 this 자체를 바인딩하지 않기 때문에 함수의 상위 스코프에 있는 this를 그대로 활용할 수 있습니다.

5. LocalStorage, SessionStorage, cookie 차이

LocalStorage, SessionStorage는 웹 브라우저 자체에 있는 특정 저장 공간입니다.
최대 5MB까지 저장이 가능하며 문자열만 저장이 가능합니다. LocalStorage는 지정된 값을 삭제하기 전까지 브라우저에 계속 그 값이 남아있습니다. 반면 SessionStorage 현재 떠 있는 텝 내에서만 유지되고 브라우저 창을 닫는 순간 사라진다는 특징이 있습니다. 쿠키는 네트워크 요청시 서버로 전송될 데이터를 저장해 놓는다는 특징이 있습니다.

6. 이벤트 버블링과 캡쳐링에 대해서 설명

이벤트 버블링은 화면의 특정 부분에서 이벤트가 발생했을 때 그 요소의 부모요소로 이벤트가 전달되는 것을 의미합니다.

이벤트 캡쳐는 반대방향을 의미합니다. addEventListener에서 option값으로 capture: true 값을 넣어주면 됩니다.

event.stopPropagation()은 해당 이벤트가 전파되는 것을 막습니다.


7. 제너레이터

제너레이터를 사용해 비동기 처리를 동기 처리처럼 구현할 수 있다. (비동기 처리의 순서가 보장된다.)  
제너레이터 함수는 function* 키워드로 선언한다. 그리고 하나 이상의 yield 문을 포함한다.

8. CORS

대부분의 웹 브라우저는 SOP (Same Origin Policy) 라는 보안 정책을 준수한다.
다른 Origin의 데이터를 읽고 싶으면 CORS 표준을 지켜서 요청하면된다. 이 문제를 해결하기 위해서 서버에서 해당 origin을 통과 시키거나, Proxy를 사용해서 origin을 우회하면 됩니다. 왜나햐면 CORS는 브라우저에 관련된 정책이기 때문에 Proxy 서버를 통해서 전달하는 요청에 대해서는 문제가 되지 않습니다.
