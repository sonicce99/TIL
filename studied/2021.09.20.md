<h1>Javascript로 트리, BFS, DFS 구현하기</h1>


<h3>트리</h3>

트리는 계층이 존재한다.
트리는 기본적을 부모-자식 관계로 부터 출발한다. 부모와 자식은 각각 '노드' 라고 불리우는데 트리를 구성하는 가장 기본 단위가 된다. 노드는 2가지 정보를 담고 있는데

1. 다른 노드와의 차별점을 두는 데이터

2. 자식들과의 관계를 담고 있는 정보


컴퓨터 메모리 구조 안에서 부모는 자식노드들의 **주소**를 갖고 있는다. 우리가 항상 부모님과의 관계를 증명하기 위해 따라다닐 필요가 없듯이, 메모리에서도 같은 노드안에 부모와 자식 노드의 데이터가 같이 저장되는 것은 아니다. *(데이터를 가지고 있지 않고 주소만 가지고 있는것)*

그저 핸드폰 번호만 알고 있으면, 전화를 통해서 연결 될 수 있다.


**구현**

구현의 핵심은, ***위에서 설명한 부모 노드에 자식의 주소를 어떻게 저장할 것인가*** 이다.

```
  class Node {
      constructor(data) {
          this.data = data; // 다른 노드와 차별점을 두는 데이터
          this.children = []; // 자식들과의 정보(주소)를 담을 배열
      }

      add(data) { // 자식 추가하는 메소드
          this.children.push(new Node(data)); // 자식 노드를 생성하고 바로 배열에 저장한다. (주소를 저장하는 행위)
      }

      remove(data) { // 자식의 정보를 지우는 메소드
          this.children = this.children.filter(child => child.data === data ? false : true); // filter 를 거쳐서 해당하는 자식의 정보를 배열에서 빼주면 된다.
      }
  }

  class Tree() {
      constructor() {
          this.root = null;
      }
  }

  const t = new Tree(); // 빈 트리를 생성 해 주고
  t.root = new Node('a'); // 루트가 node 'a'의 주소를 가리키면 'a' 의 자식들까지 접근 가능하다.
  t.root.add('b'); // a의 자식 'b', 'c'
  t.root.add('c');
  t.root.children[0].add('d'); // 'b' 의 자식으로 'd'가 추가된다.
```


***


<h3>BFS (Breadth First Search)</h3>

<h3>DFS (Depth First Search)</h3>


**트리를 순회하는 방법**

- 너비 우선 탐색 (BFS) => 층 우선 탐색

- 깊이 우선 탐색 (DFS)

***

*BFS*

트리의 가장 최상위 부모부터 자식들의 정보가 궁금하다.

예로 회사 사내 조식도에서 CEO부터 사원까지 층을 따라 사장, 부장, 대리 ... 이름을 쭉 나열하고 그 다음 평사원의 이름을 나열하면 된다. 탐색을 하는데 있어서 우선 순위가 **층**이 된다는 것이 핵심이다.




*DFS*

너비 우선 탐색은 **층**이 우선이 되었지만, 이번엔 깊이, 즉 자식들이 우선순위가 된다. 부모로부터 자식까지 아래로 쭉 훑고, 그 옆의 부모 노드로 방문이 넘어가게 된다.
아까 회사 조직도에서 BFS는 한 계급 (층)으로 이름을 나열했는데, DFS는 팀 단위라고 보면 좋을것 같다. 회사 조직도에서 사장 다음에 영업부서, 개발부서, 디자인부서가 있다고 한다면 , 각각의 부서에서는 부장-대리-사원이 있다. 영업부서의 부장-대리-사원, 개발부서의 부장-대리-사원, 디자인부서의 부장-대리-사원 순으로 이름이 나열될 것이다.




출처 : https://jun-choi-4928.medium.com/javascript%EB%A1%9C-%ED%8A%B8%EB%A6%AC-bfs-dfs-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-e96bcdadd1f3




***


<img width="713" alt="스크린샷 2021-09-21 오후 1 30 00" src="https://user-images.githubusercontent.com/87749134/134111800-a6ad79cd-d537-40ba-a1ad-3ac75e864b8a.png">
<img width="713" alt="스크린샷 2021-09-21 오후 1 30 13" src="https://user-images.githubusercontent.com/87749134/134111811-f248d889-6dde-4853-bd67-3c21ced77529.png">



***


**BFS**

```
  const graph = {
    A: ["B", "C"],
    B: ["A", "D"],
    C: ["A", "G", "H", "I"],
    D: ["B", "E", "F"],
    E: ["D"],
    F: ["D"],
    G: ["C"],
    H: ["C"],
    I: ["C", "J"],
    J: ["I"]
  };

  const bfs = (graph, startNode) => {    // 함수 표현식
    let visited = []; // 탐색을 마친 노드들
    let needVisit = []; // 탐색해야할 노드들

    needVisit.push(startNode); // 노드 탐색 시작

    while (needVisit.length !== 0) { // 탐색해야할 노드가 남아있다면
      const node = needVisit.shift(); // queue이기 때문에 선입선출, shift()를 사용한다.
      if (!visited.includes(node)) { // 해당 노드가 탐색된 적 없다면
        visited.push(node);
        needVisit = [...needVisit, ...graph[node]];
      }
    }
    return visited;
  };

  console.log(bfs(graph, "A"));
  // ["A", "B", "C", "D", "G", "H", "I", "E", "F", "J"]
```





**DFS**


```
  const graph = {
    A: ["B", "C"],
    B: ["A", "D"],
    C: ["A", "G", "H", "I"],
    D: ["B", "E", "F"],
    E: ["D"],
    F: ["D"],
    G: ["C"],
    H: ["C"],
    I: ["C", "J"],
    J: ["I"],
  };

  // (graph, 시작 정점)
  const dfs = (graph, startNode) => {
    let needVisitStack = []; // 탐색을 해야 할 노드들
    let visitedQueue = []; // 탐색을 마친 노드들

    needVisitStack.push(startNode);

    // 탐색을 해야 할 노드가 남아 있다면
    while (needVisitStack.length !== 0) {
      const node = needVisitStack.pop();
      if (!visitedQueue.includes(node)) {
        visitedQueue.push(node);
        needVisitStack = [...needVisitStack, ...graph[node]];
      }
    }

    return visitedQueue;
  };

  console.log(dfs(graph, "A"));

  // ["A", "C", "I", "J", "H", "G", "B", "D", "F", "E"]
```

DFS와 BFS는 모두 노드 수+간선 수만큼의 복잡도를 지닌다. 즉, O(n)

시간복잡도의 차이는 없다.
